
    // Code generated by Prisma CLI (https://github.com/prisma/prisma). DO NOT EDIT.

package prisma

import (
	"context"
  "errors"

  

	"github.com/prisma/prisma-client-lib-go"

	"github.com/machinebox/graphql"
)

var ErrNoResult = errors.New("query returned no result")

func Str(v string) *string { return &v }
func Int32(v int32) *int32 { return &v }
func Bool(v bool) *bool    { return &v }

type BatchPayloadExec struct {
	exec *prisma.BatchPayloadExec
}

func (exec *BatchPayloadExec) Exec(ctx context.Context) (BatchPayload, error) {
	bp, err := exec.exec.Exec(ctx)
    return BatchPayload(bp), err
}

type BatchPayload struct {
	Count int64 `json:"count"`
}

type Aggregate struct {
	Count int64 `json:"count"`
}

type Client struct {
	Client *prisma.Client
}

type Options struct {
  Endpoint  string
  Secret    string
}

func New(options *Options, opts ...graphql.ClientOption) *Client {
  endpoint := DefaultEndpoint
  secret   := Secret
	if options != nil {
    endpoint = options.Endpoint
    secret = options.Secret
	}
	return &Client{
		Client: prisma.New(endpoint, secret, opts...),
	}
}

func (client *Client) GraphQL(ctx context.Context, query string, variables map[string]interface{}) (map[string]interface{}, error) {
	return client.Client.GraphQL(ctx, query, variables)
}


var DefaultEndpoint = ""http://localhost:4467/ppmcm""
var Secret          = ""


      func (client *Client) Service (params ServiceWhereUniqueInput) *ServiceExec {
        ret := client.Client.GetOne(
          nil,
          params,
          [2]string{"ServiceWhereUniqueInput!", "Service"},
          "service",
          []string{"id","createdAt","updatedAt","name","code","description","status","type","version","canBeRemoved"})

        return &ServiceExec{ret}
      }

      type ServicesParams struct {
        Where *ServiceWhereInput `json:"where,omitempty"`
OrderBy *ServiceOrderByInput `json:"orderBy,omitempty"`
Skip *int32 `json:"skip,omitempty"`
After *string `json:"after,omitempty"`
Before *string `json:"before,omitempty"`
First *int32 `json:"first,omitempty"`
Last *int32 `json:"last,omitempty"`
      }
      func (client *Client) Services (params *ServicesParams) *ServiceExecArray {
        var wparams *prisma.WhereParams
        if params != nil {
          wparams = &prisma.WhereParams{
            Where: params.Where,
            OrderBy: (*string)(params.OrderBy),
            Skip: params.Skip,
            After: params.After,
            Before: params.Before,
            First: params.First,
            Last: params.Last,
          }
        }

        ret := client.Client.GetMany(
          nil,
          wparams,
          [3]string{"ServiceWhereInput", "ServiceOrderByInput", "Service"},
          "services",
          []string{"id","createdAt","updatedAt","name","code","description","status","type","version","canBeRemoved"})

        return &ServiceExecArray{ret}
      }

      type ServicesConnectionParams struct {
        Where *ServiceWhereInput `json:"where,omitempty"`
OrderBy *ServiceOrderByInput `json:"orderBy,omitempty"`
Skip *int32 `json:"skip,omitempty"`
After *string `json:"after,omitempty"`
Before *string `json:"before,omitempty"`
First *int32 `json:"first,omitempty"`
Last *int32 `json:"last,omitempty"`
      }
      func (client *Client) ServicesConnection (params *ServicesConnectionParams) (ServiceConnectionExec) {
        panic("not implemented")
      }

      func (client *Client) User (params UserWhereUniqueInput) *UserExec {
        ret := client.Client.GetOne(
          nil,
          params,
          [2]string{"UserWhereUniqueInput!", "User"},
          "user",
          []string{"id","name"})

        return &UserExec{ret}
      }

      type UsersParams struct {
        Where *UserWhereInput `json:"where,omitempty"`
OrderBy *UserOrderByInput `json:"orderBy,omitempty"`
Skip *int32 `json:"skip,omitempty"`
After *string `json:"after,omitempty"`
Before *string `json:"before,omitempty"`
First *int32 `json:"first,omitempty"`
Last *int32 `json:"last,omitempty"`
      }
      func (client *Client) Users (params *UsersParams) *UserExecArray {
        var wparams *prisma.WhereParams
        if params != nil {
          wparams = &prisma.WhereParams{
            Where: params.Where,
            OrderBy: (*string)(params.OrderBy),
            Skip: params.Skip,
            After: params.After,
            Before: params.Before,
            First: params.First,
            Last: params.Last,
          }
        }

        ret := client.Client.GetMany(
          nil,
          wparams,
          [3]string{"UserWhereInput", "UserOrderByInput", "User"},
          "users",
          []string{"id","name"})

        return &UserExecArray{ret}
      }

      type UsersConnectionParams struct {
        Where *UserWhereInput `json:"where,omitempty"`
OrderBy *UserOrderByInput `json:"orderBy,omitempty"`
Skip *int32 `json:"skip,omitempty"`
After *string `json:"after,omitempty"`
Before *string `json:"before,omitempty"`
First *int32 `json:"first,omitempty"`
Last *int32 `json:"last,omitempty"`
      }
      func (client *Client) UsersConnection (params *UsersConnectionParams) (UserConnectionExec) {
        panic("not implemented")
      }



      func (client *Client) CreateService (params ServiceCreateInput) *ServiceExec {
        ret := client.Client.Create(
          params,
          [2]string{"ServiceCreateInput!", "Service"},
          "createService",
          []string{"id","createdAt","updatedAt","name","code","description","status","type","version","canBeRemoved"})

        return &ServiceExec{ret}
      }

      type ServiceUpdateParams struct {
        Data ServiceUpdateInput `json:"data"`
Where ServiceWhereUniqueInput `json:"where"`
      }
      func (client *Client) UpdateService (params ServiceUpdateParams) *ServiceExec {
        ret := client.Client.Update(
                 prisma.UpdateParams{
                   Data: params.Data,
                   Where: params.Where,
                 },
                 [3]string{"ServiceUpdateInput!", "ServiceWhereUniqueInput!", "Service"},
                 "updateService",
                 []string{"id","createdAt","updatedAt","name","code","description","status","type","version","canBeRemoved"})

        return &ServiceExec{ret}
      }

      type ServiceUpdateManyParams struct {
        Data ServiceUpdateManyMutationInput `json:"data"`
Where *ServiceWhereInput `json:"where,omitempty"`
      }
      func (client *Client) UpdateManyServices (params ServiceUpdateManyParams) *BatchPayloadExec {
        exec := client.Client.UpdateMany(
          prisma.UpdateParams{
            Data: params.Data,
            Where: params.Where,
          },
          [2]string{"ServiceUpdateManyMutationInput!", "ServiceWhereInput"},
          "updateManyServices")
        return &BatchPayloadExec{exec}
      }

      type ServiceUpsertParams struct {
        Where ServiceWhereUniqueInput `json:"where"`
Create ServiceCreateInput `json:"create"`
Update ServiceUpdateInput `json:"update"`
      }
      func (client *Client) UpsertService (params ServiceUpsertParams) *ServiceExec {
        uparams := &prisma.UpsertParams{
          Where:  params.Where,
          Create: params.Create,
          Update: params.Update,
        }
        ret := client.Client.Upsert(
          uparams,
          [4]string{"ServiceWhereUniqueInput!", "ServiceCreateInput!", "ServiceUpdateInput!","Service"},
          "upsertService",
          []string{"id","createdAt","updatedAt","name","code","description","status","type","version","canBeRemoved"})

        return &ServiceExec{ret}
      }

      func (client *Client) DeleteService (params ServiceWhereUniqueInput) *ServiceExec {
        ret := client.Client.Delete(
          params,
          [2]string{"ServiceWhereUniqueInput!", "Service"},
          "deleteService",
          []string{"id","createdAt","updatedAt","name","code","description","status","type","version","canBeRemoved"})

        return &ServiceExec{ret}
      }

      func (client *Client) DeleteManyServices (params *ServiceWhereInput) *BatchPayloadExec {
        exec := client.Client.DeleteMany(params, "ServiceWhereInput", "deleteManyServices")
        return &BatchPayloadExec{exec}
      }

      func (client *Client) CreateUser (params UserCreateInput) *UserExec {
        ret := client.Client.Create(
          params,
          [2]string{"UserCreateInput!", "User"},
          "createUser",
          []string{"id","name"})

        return &UserExec{ret}
      }

      type UserUpdateParams struct {
        Data UserUpdateInput `json:"data"`
Where UserWhereUniqueInput `json:"where"`
      }
      func (client *Client) UpdateUser (params UserUpdateParams) *UserExec {
        ret := client.Client.Update(
                 prisma.UpdateParams{
                   Data: params.Data,
                   Where: params.Where,
                 },
                 [3]string{"UserUpdateInput!", "UserWhereUniqueInput!", "User"},
                 "updateUser",
                 []string{"id","name"})

        return &UserExec{ret}
      }

      type UserUpdateManyParams struct {
        Data UserUpdateManyMutationInput `json:"data"`
Where *UserWhereInput `json:"where,omitempty"`
      }
      func (client *Client) UpdateManyUsers (params UserUpdateManyParams) *BatchPayloadExec {
        exec := client.Client.UpdateMany(
          prisma.UpdateParams{
            Data: params.Data,
            Where: params.Where,
          },
          [2]string{"UserUpdateManyMutationInput!", "UserWhereInput"},
          "updateManyUsers")
        return &BatchPayloadExec{exec}
      }

      type UserUpsertParams struct {
        Where UserWhereUniqueInput `json:"where"`
Create UserCreateInput `json:"create"`
Update UserUpdateInput `json:"update"`
      }
      func (client *Client) UpsertUser (params UserUpsertParams) *UserExec {
        uparams := &prisma.UpsertParams{
          Where:  params.Where,
          Create: params.Create,
          Update: params.Update,
        }
        ret := client.Client.Upsert(
          uparams,
          [4]string{"UserWhereUniqueInput!", "UserCreateInput!", "UserUpdateInput!","User"},
          "upsertUser",
          []string{"id","name"})

        return &UserExec{ret}
      }

      func (client *Client) DeleteUser (params UserWhereUniqueInput) *UserExec {
        ret := client.Client.Delete(
          params,
          [2]string{"UserWhereUniqueInput!", "User"},
          "deleteUser",
          []string{"id","name"})

        return &UserExec{ret}
      }

      func (client *Client) DeleteManyUsers (params *UserWhereInput) *BatchPayloadExec {
        exec := client.Client.DeleteMany(params, "UserWhereInput", "deleteManyUsers")
        return &BatchPayloadExec{exec}
      }


        type ServiceOrderByInput string
        const (
          ServiceOrderByInputIDAsc ServiceOrderByInput = "id_ASC"
ServiceOrderByInputIDDesc ServiceOrderByInput = "id_DESC"
ServiceOrderByInputCreatedAtAsc ServiceOrderByInput = "createdAt_ASC"
ServiceOrderByInputCreatedAtDesc ServiceOrderByInput = "createdAt_DESC"
ServiceOrderByInputUpdatedAtAsc ServiceOrderByInput = "updatedAt_ASC"
ServiceOrderByInputUpdatedAtDesc ServiceOrderByInput = "updatedAt_DESC"
ServiceOrderByInputNameAsc ServiceOrderByInput = "name_ASC"
ServiceOrderByInputNameDesc ServiceOrderByInput = "name_DESC"
ServiceOrderByInputCodeAsc ServiceOrderByInput = "code_ASC"
ServiceOrderByInputCodeDesc ServiceOrderByInput = "code_DESC"
ServiceOrderByInputDescriptionAsc ServiceOrderByInput = "description_ASC"
ServiceOrderByInputDescriptionDesc ServiceOrderByInput = "description_DESC"
ServiceOrderByInputStatusAsc ServiceOrderByInput = "status_ASC"
ServiceOrderByInputStatusDesc ServiceOrderByInput = "status_DESC"
ServiceOrderByInputTypeAsc ServiceOrderByInput = "type_ASC"
ServiceOrderByInputTypeDesc ServiceOrderByInput = "type_DESC"
ServiceOrderByInputVersionAsc ServiceOrderByInput = "version_ASC"
ServiceOrderByInputVersionDesc ServiceOrderByInput = "version_DESC"
ServiceOrderByInputCanBeRemovedAsc ServiceOrderByInput = "canBeRemoved_ASC"
ServiceOrderByInputCanBeRemovedDesc ServiceOrderByInput = "canBeRemoved_DESC"
          )

        type UserOrderByInput string
        const (
          UserOrderByInputIDAsc UserOrderByInput = "id_ASC"
UserOrderByInputIDDesc UserOrderByInput = "id_DESC"
UserOrderByInputNameAsc UserOrderByInput = "name_ASC"
UserOrderByInputNameDesc UserOrderByInput = "name_DESC"
UserOrderByInputCreatedAtAsc UserOrderByInput = "createdAt_ASC"
UserOrderByInputCreatedAtDesc UserOrderByInput = "createdAt_DESC"
UserOrderByInputUpdatedAtAsc UserOrderByInput = "updatedAt_ASC"
UserOrderByInputUpdatedAtDesc UserOrderByInput = "updatedAt_DESC"
          )

        type MutationType string
        const (
          MutationTypeCreated MutationType = "CREATED"
MutationTypeUpdated MutationType = "UPDATED"
MutationTypeDeleted MutationType = "DELETED"
          )

      type ServiceCreateManyInput struct {
        Create []ServiceCreateInput `json:"create,omitempty"`
Connect []ServiceWhereUniqueInput `json:"connect,omitempty"`
          }

      type ServiceWhereUniqueInput struct {
        ID *string `json:"id,omitempty"`
Code *string `json:"code,omitempty"`
          }

      type UserWhereInput struct {
        ID *string `json:"id,omitempty"`
IDNot *string `json:"id_not,omitempty"`
IDIn []string `json:"id_in,omitempty"`
IDNotIn []string `json:"id_not_in,omitempty"`
IDLt *string `json:"id_lt,omitempty"`
IDLte *string `json:"id_lte,omitempty"`
IDGt *string `json:"id_gt,omitempty"`
IDGte *string `json:"id_gte,omitempty"`
IDContains *string `json:"id_contains,omitempty"`
IDNotContains *string `json:"id_not_contains,omitempty"`
IDStartsWith *string `json:"id_starts_with,omitempty"`
IDNotStartsWith *string `json:"id_not_starts_with,omitempty"`
IDEndsWith *string `json:"id_ends_with,omitempty"`
IDNotEndsWith *string `json:"id_not_ends_with,omitempty"`
Name *string `json:"name,omitempty"`
NameNot *string `json:"name_not,omitempty"`
NameIn []string `json:"name_in,omitempty"`
NameNotIn []string `json:"name_not_in,omitempty"`
NameLt *string `json:"name_lt,omitempty"`
NameLte *string `json:"name_lte,omitempty"`
NameGt *string `json:"name_gt,omitempty"`
NameGte *string `json:"name_gte,omitempty"`
NameContains *string `json:"name_contains,omitempty"`
NameNotContains *string `json:"name_not_contains,omitempty"`
NameStartsWith *string `json:"name_starts_with,omitempty"`
NameNotStartsWith *string `json:"name_not_starts_with,omitempty"`
NameEndsWith *string `json:"name_ends_with,omitempty"`
NameNotEndsWith *string `json:"name_not_ends_with,omitempty"`
And []UserWhereInput `json:"AND,omitempty"`
Or []UserWhereInput `json:"OR,omitempty"`
Not []UserWhereInput `json:"NOT,omitempty"`
          }

      type ServiceWhereInput struct {
        ID *string `json:"id,omitempty"`
IDNot *string `json:"id_not,omitempty"`
IDIn []string `json:"id_in,omitempty"`
IDNotIn []string `json:"id_not_in,omitempty"`
IDLt *string `json:"id_lt,omitempty"`
IDLte *string `json:"id_lte,omitempty"`
IDGt *string `json:"id_gt,omitempty"`
IDGte *string `json:"id_gte,omitempty"`
IDContains *string `json:"id_contains,omitempty"`
IDNotContains *string `json:"id_not_contains,omitempty"`
IDStartsWith *string `json:"id_starts_with,omitempty"`
IDNotStartsWith *string `json:"id_not_starts_with,omitempty"`
IDEndsWith *string `json:"id_ends_with,omitempty"`
IDNotEndsWith *string `json:"id_not_ends_with,omitempty"`
CreatedAt *string `json:"createdAt,omitempty"`
CreatedAtNot *string `json:"createdAt_not,omitempty"`
CreatedAtIn []string `json:"createdAt_in,omitempty"`
CreatedAtNotIn []string `json:"createdAt_not_in,omitempty"`
CreatedAtLt *string `json:"createdAt_lt,omitempty"`
CreatedAtLte *string `json:"createdAt_lte,omitempty"`
CreatedAtGt *string `json:"createdAt_gt,omitempty"`
CreatedAtGte *string `json:"createdAt_gte,omitempty"`
UpdatedAt *string `json:"updatedAt,omitempty"`
UpdatedAtNot *string `json:"updatedAt_not,omitempty"`
UpdatedAtIn []string `json:"updatedAt_in,omitempty"`
UpdatedAtNotIn []string `json:"updatedAt_not_in,omitempty"`
UpdatedAtLt *string `json:"updatedAt_lt,omitempty"`
UpdatedAtLte *string `json:"updatedAt_lte,omitempty"`
UpdatedAtGt *string `json:"updatedAt_gt,omitempty"`
UpdatedAtGte *string `json:"updatedAt_gte,omitempty"`
Name *string `json:"name,omitempty"`
NameNot *string `json:"name_not,omitempty"`
NameIn []string `json:"name_in,omitempty"`
NameNotIn []string `json:"name_not_in,omitempty"`
NameLt *string `json:"name_lt,omitempty"`
NameLte *string `json:"name_lte,omitempty"`
NameGt *string `json:"name_gt,omitempty"`
NameGte *string `json:"name_gte,omitempty"`
NameContains *string `json:"name_contains,omitempty"`
NameNotContains *string `json:"name_not_contains,omitempty"`
NameStartsWith *string `json:"name_starts_with,omitempty"`
NameNotStartsWith *string `json:"name_not_starts_with,omitempty"`
NameEndsWith *string `json:"name_ends_with,omitempty"`
NameNotEndsWith *string `json:"name_not_ends_with,omitempty"`
Code *string `json:"code,omitempty"`
CodeNot *string `json:"code_not,omitempty"`
CodeIn []string `json:"code_in,omitempty"`
CodeNotIn []string `json:"code_not_in,omitempty"`
CodeLt *string `json:"code_lt,omitempty"`
CodeLte *string `json:"code_lte,omitempty"`
CodeGt *string `json:"code_gt,omitempty"`
CodeGte *string `json:"code_gte,omitempty"`
CodeContains *string `json:"code_contains,omitempty"`
CodeNotContains *string `json:"code_not_contains,omitempty"`
CodeStartsWith *string `json:"code_starts_with,omitempty"`
CodeNotStartsWith *string `json:"code_not_starts_with,omitempty"`
CodeEndsWith *string `json:"code_ends_with,omitempty"`
CodeNotEndsWith *string `json:"code_not_ends_with,omitempty"`
Description *string `json:"description,omitempty"`
DescriptionNot *string `json:"description_not,omitempty"`
DescriptionIn []string `json:"description_in,omitempty"`
DescriptionNotIn []string `json:"description_not_in,omitempty"`
DescriptionLt *string `json:"description_lt,omitempty"`
DescriptionLte *string `json:"description_lte,omitempty"`
DescriptionGt *string `json:"description_gt,omitempty"`
DescriptionGte *string `json:"description_gte,omitempty"`
DescriptionContains *string `json:"description_contains,omitempty"`
DescriptionNotContains *string `json:"description_not_contains,omitempty"`
DescriptionStartsWith *string `json:"description_starts_with,omitempty"`
DescriptionNotStartsWith *string `json:"description_not_starts_with,omitempty"`
DescriptionEndsWith *string `json:"description_ends_with,omitempty"`
DescriptionNotEndsWith *string `json:"description_not_ends_with,omitempty"`
Status *string `json:"status,omitempty"`
StatusNot *string `json:"status_not,omitempty"`
StatusIn []string `json:"status_in,omitempty"`
StatusNotIn []string `json:"status_not_in,omitempty"`
StatusLt *string `json:"status_lt,omitempty"`
StatusLte *string `json:"status_lte,omitempty"`
StatusGt *string `json:"status_gt,omitempty"`
StatusGte *string `json:"status_gte,omitempty"`
StatusContains *string `json:"status_contains,omitempty"`
StatusNotContains *string `json:"status_not_contains,omitempty"`
StatusStartsWith *string `json:"status_starts_with,omitempty"`
StatusNotStartsWith *string `json:"status_not_starts_with,omitempty"`
StatusEndsWith *string `json:"status_ends_with,omitempty"`
StatusNotEndsWith *string `json:"status_not_ends_with,omitempty"`
Type *string `json:"type,omitempty"`
TypeNot *string `json:"type_not,omitempty"`
TypeIn []string `json:"type_in,omitempty"`
TypeNotIn []string `json:"type_not_in,omitempty"`
TypeLt *string `json:"type_lt,omitempty"`
TypeLte *string `json:"type_lte,omitempty"`
TypeGt *string `json:"type_gt,omitempty"`
TypeGte *string `json:"type_gte,omitempty"`
TypeContains *string `json:"type_contains,omitempty"`
TypeNotContains *string `json:"type_not_contains,omitempty"`
TypeStartsWith *string `json:"type_starts_with,omitempty"`
TypeNotStartsWith *string `json:"type_not_starts_with,omitempty"`
TypeEndsWith *string `json:"type_ends_with,omitempty"`
TypeNotEndsWith *string `json:"type_not_ends_with,omitempty"`
Version *string `json:"version,omitempty"`
VersionNot *string `json:"version_not,omitempty"`
VersionIn []string `json:"version_in,omitempty"`
VersionNotIn []string `json:"version_not_in,omitempty"`
VersionLt *string `json:"version_lt,omitempty"`
VersionLte *string `json:"version_lte,omitempty"`
VersionGt *string `json:"version_gt,omitempty"`
VersionGte *string `json:"version_gte,omitempty"`
VersionContains *string `json:"version_contains,omitempty"`
VersionNotContains *string `json:"version_not_contains,omitempty"`
VersionStartsWith *string `json:"version_starts_with,omitempty"`
VersionNotStartsWith *string `json:"version_not_starts_with,omitempty"`
VersionEndsWith *string `json:"version_ends_with,omitempty"`
VersionNotEndsWith *string `json:"version_not_ends_with,omitempty"`
CanBeRemoved *bool `json:"canBeRemoved,omitempty"`
CanBeRemovedNot *bool `json:"canBeRemoved_not,omitempty"`
DependentServicesEvery *ServiceWhereInput `json:"dependentServices_every,omitempty"`
DependentServicesSome *ServiceWhereInput `json:"dependentServices_some,omitempty"`
DependentServicesNone *ServiceWhereInput `json:"dependentServices_none,omitempty"`
And []ServiceWhereInput `json:"AND,omitempty"`
Or []ServiceWhereInput `json:"OR,omitempty"`
Not []ServiceWhereInput `json:"NOT,omitempty"`
          }

      type ServiceUpdateManyWithWhereNestedInput struct {
        Where ServiceScalarWhereInput `json:"where"`
Data ServiceUpdateManyDataInput `json:"data"`
          }

      type ServiceUpdateManyInput struct {
        Create []ServiceCreateInput `json:"create,omitempty"`
Update []ServiceUpdateWithWhereUniqueNestedInput `json:"update,omitempty"`
Upsert []ServiceUpsertWithWhereUniqueNestedInput `json:"upsert,omitempty"`
Delete []ServiceWhereUniqueInput `json:"delete,omitempty"`
Connect []ServiceWhereUniqueInput `json:"connect,omitempty"`
Disconnect []ServiceWhereUniqueInput `json:"disconnect,omitempty"`
DeleteMany []ServiceScalarWhereInput `json:"deleteMany,omitempty"`
UpdateMany []ServiceUpdateManyWithWhereNestedInput `json:"updateMany,omitempty"`
          }

      type ServiceScalarWhereInput struct {
        ID *string `json:"id,omitempty"`
IDNot *string `json:"id_not,omitempty"`
IDIn []string `json:"id_in,omitempty"`
IDNotIn []string `json:"id_not_in,omitempty"`
IDLt *string `json:"id_lt,omitempty"`
IDLte *string `json:"id_lte,omitempty"`
IDGt *string `json:"id_gt,omitempty"`
IDGte *string `json:"id_gte,omitempty"`
IDContains *string `json:"id_contains,omitempty"`
IDNotContains *string `json:"id_not_contains,omitempty"`
IDStartsWith *string `json:"id_starts_with,omitempty"`
IDNotStartsWith *string `json:"id_not_starts_with,omitempty"`
IDEndsWith *string `json:"id_ends_with,omitempty"`
IDNotEndsWith *string `json:"id_not_ends_with,omitempty"`
CreatedAt *string `json:"createdAt,omitempty"`
CreatedAtNot *string `json:"createdAt_not,omitempty"`
CreatedAtIn []string `json:"createdAt_in,omitempty"`
CreatedAtNotIn []string `json:"createdAt_not_in,omitempty"`
CreatedAtLt *string `json:"createdAt_lt,omitempty"`
CreatedAtLte *string `json:"createdAt_lte,omitempty"`
CreatedAtGt *string `json:"createdAt_gt,omitempty"`
CreatedAtGte *string `json:"createdAt_gte,omitempty"`
UpdatedAt *string `json:"updatedAt,omitempty"`
UpdatedAtNot *string `json:"updatedAt_not,omitempty"`
UpdatedAtIn []string `json:"updatedAt_in,omitempty"`
UpdatedAtNotIn []string `json:"updatedAt_not_in,omitempty"`
UpdatedAtLt *string `json:"updatedAt_lt,omitempty"`
UpdatedAtLte *string `json:"updatedAt_lte,omitempty"`
UpdatedAtGt *string `json:"updatedAt_gt,omitempty"`
UpdatedAtGte *string `json:"updatedAt_gte,omitempty"`
Name *string `json:"name,omitempty"`
NameNot *string `json:"name_not,omitempty"`
NameIn []string `json:"name_in,omitempty"`
NameNotIn []string `json:"name_not_in,omitempty"`
NameLt *string `json:"name_lt,omitempty"`
NameLte *string `json:"name_lte,omitempty"`
NameGt *string `json:"name_gt,omitempty"`
NameGte *string `json:"name_gte,omitempty"`
NameContains *string `json:"name_contains,omitempty"`
NameNotContains *string `json:"name_not_contains,omitempty"`
NameStartsWith *string `json:"name_starts_with,omitempty"`
NameNotStartsWith *string `json:"name_not_starts_with,omitempty"`
NameEndsWith *string `json:"name_ends_with,omitempty"`
NameNotEndsWith *string `json:"name_not_ends_with,omitempty"`
Code *string `json:"code,omitempty"`
CodeNot *string `json:"code_not,omitempty"`
CodeIn []string `json:"code_in,omitempty"`
CodeNotIn []string `json:"code_not_in,omitempty"`
CodeLt *string `json:"code_lt,omitempty"`
CodeLte *string `json:"code_lte,omitempty"`
CodeGt *string `json:"code_gt,omitempty"`
CodeGte *string `json:"code_gte,omitempty"`
CodeContains *string `json:"code_contains,omitempty"`
CodeNotContains *string `json:"code_not_contains,omitempty"`
CodeStartsWith *string `json:"code_starts_with,omitempty"`
CodeNotStartsWith *string `json:"code_not_starts_with,omitempty"`
CodeEndsWith *string `json:"code_ends_with,omitempty"`
CodeNotEndsWith *string `json:"code_not_ends_with,omitempty"`
Description *string `json:"description,omitempty"`
DescriptionNot *string `json:"description_not,omitempty"`
DescriptionIn []string `json:"description_in,omitempty"`
DescriptionNotIn []string `json:"description_not_in,omitempty"`
DescriptionLt *string `json:"description_lt,omitempty"`
DescriptionLte *string `json:"description_lte,omitempty"`
DescriptionGt *string `json:"description_gt,omitempty"`
DescriptionGte *string `json:"description_gte,omitempty"`
DescriptionContains *string `json:"description_contains,omitempty"`
DescriptionNotContains *string `json:"description_not_contains,omitempty"`
DescriptionStartsWith *string `json:"description_starts_with,omitempty"`
DescriptionNotStartsWith *string `json:"description_not_starts_with,omitempty"`
DescriptionEndsWith *string `json:"description_ends_with,omitempty"`
DescriptionNotEndsWith *string `json:"description_not_ends_with,omitempty"`
Status *string `json:"status,omitempty"`
StatusNot *string `json:"status_not,omitempty"`
StatusIn []string `json:"status_in,omitempty"`
StatusNotIn []string `json:"status_not_in,omitempty"`
StatusLt *string `json:"status_lt,omitempty"`
StatusLte *string `json:"status_lte,omitempty"`
StatusGt *string `json:"status_gt,omitempty"`
StatusGte *string `json:"status_gte,omitempty"`
StatusContains *string `json:"status_contains,omitempty"`
StatusNotContains *string `json:"status_not_contains,omitempty"`
StatusStartsWith *string `json:"status_starts_with,omitempty"`
StatusNotStartsWith *string `json:"status_not_starts_with,omitempty"`
StatusEndsWith *string `json:"status_ends_with,omitempty"`
StatusNotEndsWith *string `json:"status_not_ends_with,omitempty"`
Type *string `json:"type,omitempty"`
TypeNot *string `json:"type_not,omitempty"`
TypeIn []string `json:"type_in,omitempty"`
TypeNotIn []string `json:"type_not_in,omitempty"`
TypeLt *string `json:"type_lt,omitempty"`
TypeLte *string `json:"type_lte,omitempty"`
TypeGt *string `json:"type_gt,omitempty"`
TypeGte *string `json:"type_gte,omitempty"`
TypeContains *string `json:"type_contains,omitempty"`
TypeNotContains *string `json:"type_not_contains,omitempty"`
TypeStartsWith *string `json:"type_starts_with,omitempty"`
TypeNotStartsWith *string `json:"type_not_starts_with,omitempty"`
TypeEndsWith *string `json:"type_ends_with,omitempty"`
TypeNotEndsWith *string `json:"type_not_ends_with,omitempty"`
Version *string `json:"version,omitempty"`
VersionNot *string `json:"version_not,omitempty"`
VersionIn []string `json:"version_in,omitempty"`
VersionNotIn []string `json:"version_not_in,omitempty"`
VersionLt *string `json:"version_lt,omitempty"`
VersionLte *string `json:"version_lte,omitempty"`
VersionGt *string `json:"version_gt,omitempty"`
VersionGte *string `json:"version_gte,omitempty"`
VersionContains *string `json:"version_contains,omitempty"`
VersionNotContains *string `json:"version_not_contains,omitempty"`
VersionStartsWith *string `json:"version_starts_with,omitempty"`
VersionNotStartsWith *string `json:"version_not_starts_with,omitempty"`
VersionEndsWith *string `json:"version_ends_with,omitempty"`
VersionNotEndsWith *string `json:"version_not_ends_with,omitempty"`
CanBeRemoved *bool `json:"canBeRemoved,omitempty"`
CanBeRemovedNot *bool `json:"canBeRemoved_not,omitempty"`
And []ServiceScalarWhereInput `json:"AND,omitempty"`
Or []ServiceScalarWhereInput `json:"OR,omitempty"`
Not []ServiceScalarWhereInput `json:"NOT,omitempty"`
          }

      type ServiceSubscriptionWhereInput struct {
        MutationIn []MutationType `json:"mutation_in,omitempty"`
UpdatedFieldsContains *string `json:"updatedFields_contains,omitempty"`
UpdatedFieldsContainsEvery []string `json:"updatedFields_contains_every,omitempty"`
UpdatedFieldsContainsSome []string `json:"updatedFields_contains_some,omitempty"`
Node *ServiceWhereInput `json:"node,omitempty"`
And []ServiceSubscriptionWhereInput `json:"AND,omitempty"`
Or []ServiceSubscriptionWhereInput `json:"OR,omitempty"`
Not []ServiceSubscriptionWhereInput `json:"NOT,omitempty"`
          }

      type ServiceUpsertWithWhereUniqueNestedInput struct {
        Where ServiceWhereUniqueInput `json:"where"`
Update ServiceUpdateDataInput `json:"update"`
Create ServiceCreateInput `json:"create"`
          }

      type UserUpdateInput struct {
        Name *string `json:"name,omitempty"`
          }

      type ServiceUpdateDataInput struct {
        Name *string `json:"name,omitempty"`
Code *string `json:"code,omitempty"`
Description *string `json:"description,omitempty"`
Status *string `json:"status,omitempty"`
Type *string `json:"type,omitempty"`
Version *string `json:"version,omitempty"`
CanBeRemoved *bool `json:"canBeRemoved,omitempty"`
DependentServices *ServiceUpdateManyInput `json:"dependentServices,omitempty"`
          }

      type ServiceUpdateManyMutationInput struct {
        Name *string `json:"name,omitempty"`
Code *string `json:"code,omitempty"`
Description *string `json:"description,omitempty"`
Status *string `json:"status,omitempty"`
Type *string `json:"type,omitempty"`
Version *string `json:"version,omitempty"`
CanBeRemoved *bool `json:"canBeRemoved,omitempty"`
          }

      type ServiceUpdateManyDataInput struct {
        Name *string `json:"name,omitempty"`
Code *string `json:"code,omitempty"`
Description *string `json:"description,omitempty"`
Status *string `json:"status,omitempty"`
Type *string `json:"type,omitempty"`
Version *string `json:"version,omitempty"`
CanBeRemoved *bool `json:"canBeRemoved,omitempty"`
          }

      type ServiceUpdateInput struct {
        Name *string `json:"name,omitempty"`
Code *string `json:"code,omitempty"`
Description *string `json:"description,omitempty"`
Status *string `json:"status,omitempty"`
Type *string `json:"type,omitempty"`
Version *string `json:"version,omitempty"`
CanBeRemoved *bool `json:"canBeRemoved,omitempty"`
DependentServices *ServiceUpdateManyInput `json:"dependentServices,omitempty"`
          }

      type ServiceUpdateWithWhereUniqueNestedInput struct {
        Where ServiceWhereUniqueInput `json:"where"`
Data ServiceUpdateDataInput `json:"data"`
          }

      type ServiceCreateInput struct {
        Name string `json:"name"`
Code string `json:"code"`
Description *string `json:"description,omitempty"`
Status string `json:"status"`
Type string `json:"type"`
Version *string `json:"version,omitempty"`
CanBeRemoved *bool `json:"canBeRemoved,omitempty"`
DependentServices *ServiceCreateManyInput `json:"dependentServices,omitempty"`
          }

      type UserSubscriptionWhereInput struct {
        MutationIn []MutationType `json:"mutation_in,omitempty"`
UpdatedFieldsContains *string `json:"updatedFields_contains,omitempty"`
UpdatedFieldsContainsEvery []string `json:"updatedFields_contains_every,omitempty"`
UpdatedFieldsContainsSome []string `json:"updatedFields_contains_some,omitempty"`
Node *UserWhereInput `json:"node,omitempty"`
And []UserSubscriptionWhereInput `json:"AND,omitempty"`
Or []UserSubscriptionWhereInput `json:"OR,omitempty"`
Not []UserSubscriptionWhereInput `json:"NOT,omitempty"`
          }

      type UserWhereUniqueInput struct {
        ID *string `json:"id,omitempty"`
          }

      type UserCreateInput struct {
        Name string `json:"name"`
          }

      type UserUpdateManyMutationInput struct {
        Name *string `json:"name,omitempty"`
          }


        type UserPreviousValuesExec struct {
          exec *prisma.Exec
        }

        

          func (instance UserPreviousValuesExec) Exec(ctx context.Context) (*UserPreviousValues, error) {
            var v UserPreviousValues
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance UserPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type UserPreviousValuesExecArray struct {
            exec *prisma.Exec
          }

          func (instance UserPreviousValuesExecArray) Exec(ctx context.Context) ([]UserPreviousValues, error) {
            var v []UserPreviousValues
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type UserPreviousValues struct {
          ID string `json:"id"`
Name string `json:"name"`
        }


        type ServiceSubscriptionPayloadExec struct {
          exec *prisma.Exec
        }

        
                func (instance *ServiceSubscriptionPayloadExec) Node() *ServiceExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "Service"},
                    "node",
                    []string{"id","createdAt","updatedAt","name","code","description","status","type","version","canBeRemoved"})

                  return &ServiceExec{ret}
                }

                func (instance *ServiceSubscriptionPayloadExec) PreviousValues() *ServicePreviousValuesExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "ServicePreviousValues"},
                    "previousValues",
                    []string{"id","createdAt","updatedAt","name","code","description","status","type","version","canBeRemoved"})

                  return &ServicePreviousValuesExec{ret}
                }

          func (instance ServiceSubscriptionPayloadExec) Exec(ctx context.Context) (*ServiceSubscriptionPayload, error) {
            var v ServiceSubscriptionPayload
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance ServiceSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type ServiceSubscriptionPayloadExecArray struct {
            exec *prisma.Exec
          }

          func (instance ServiceSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]ServiceSubscriptionPayload, error) {
            var v []ServiceSubscriptionPayload
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type ServiceSubscriptionPayload struct {
          UpdatedFields []string `json:"updatedFields,omitempty"`
        }

        type UserSubscriptionPayloadExec struct {
          exec *prisma.Exec
        }

        
                func (instance *UserSubscriptionPayloadExec) Node() *UserExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "User"},
                    "node",
                    []string{"id","name"})

                  return &UserExec{ret}
                }

                func (instance *UserSubscriptionPayloadExec) PreviousValues() *UserPreviousValuesExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "UserPreviousValues"},
                    "previousValues",
                    []string{"id","name"})

                  return &UserPreviousValuesExec{ret}
                }

          func (instance UserSubscriptionPayloadExec) Exec(ctx context.Context) (*UserSubscriptionPayload, error) {
            var v UserSubscriptionPayload
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance UserSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type UserSubscriptionPayloadExecArray struct {
            exec *prisma.Exec
          }

          func (instance UserSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]UserSubscriptionPayload, error) {
            var v []UserSubscriptionPayload
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type UserSubscriptionPayload struct {
          UpdatedFields []string `json:"updatedFields,omitempty"`
        }

        type ServiceEdgeExec struct {
          exec *prisma.Exec
        }

        
                func (instance *ServiceEdgeExec) Node() *ServiceExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "Service"},
                    "node",
                    []string{"id","createdAt","updatedAt","name","code","description","status","type","version","canBeRemoved"})

                  return &ServiceExec{ret}
                }

          func (instance ServiceEdgeExec) Exec(ctx context.Context) (*ServiceEdge, error) {
            var v ServiceEdge
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance ServiceEdgeExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type ServiceEdgeExecArray struct {
            exec *prisma.Exec
          }

          func (instance ServiceEdgeExecArray) Exec(ctx context.Context) ([]ServiceEdge, error) {
            var v []ServiceEdge
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type ServiceEdge struct {
          Cursor string `json:"cursor"`
        }

        type UserConnectionExec struct {
          exec *prisma.Exec
        }

        
                func (instance *UserConnectionExec) PageInfo() *PageInfoExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "PageInfo"},
                    "pageInfo",
                    []string{"hasNextPage","hasPreviousPage","startCursor","endCursor"})

                  return &PageInfoExec{ret}
                }

                func (instance *UserConnectionExec) Edges() *UserEdgeExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "UserEdge"},
                    "edges",
                    []string{"cursor"})

                  return &UserEdgeExec{ret}
                }

                  func (instance *UserConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
                    ret := instance.exec.Client.GetOne(
                      instance.exec,
                      nil,
                      [2]string{"", "AggregateUser"},
                      "aggregate",
                      []string{"count"})

                    var v Aggregate
                    _, err := ret.Exec(ctx, &v)
                    return v, err
                  }

          func (instance UserConnectionExec) Exec(ctx context.Context) (*UserConnection, error) {
            var v UserConnection
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance UserConnectionExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type UserConnectionExecArray struct {
            exec *prisma.Exec
          }

          func (instance UserConnectionExecArray) Exec(ctx context.Context) ([]UserConnection, error) {
            var v []UserConnection
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type UserConnection struct {
          
        }

        type ServicePreviousValuesExec struct {
          exec *prisma.Exec
        }

        

          func (instance ServicePreviousValuesExec) Exec(ctx context.Context) (*ServicePreviousValues, error) {
            var v ServicePreviousValues
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance ServicePreviousValuesExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type ServicePreviousValuesExecArray struct {
            exec *prisma.Exec
          }

          func (instance ServicePreviousValuesExecArray) Exec(ctx context.Context) ([]ServicePreviousValues, error) {
            var v []ServicePreviousValues
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type ServicePreviousValues struct {
          ID string `json:"id"`
CreatedAt string `json:"createdAt"`
UpdatedAt string `json:"updatedAt"`
Name string `json:"name"`
Code string `json:"code"`
Description *string `json:"description,omitempty"`
Status string `json:"status"`
Type string `json:"type"`
Version *string `json:"version,omitempty"`
CanBeRemoved bool `json:"canBeRemoved"`
        }

        type ServiceConnectionExec struct {
          exec *prisma.Exec
        }

        
                func (instance *ServiceConnectionExec) PageInfo() *PageInfoExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "PageInfo"},
                    "pageInfo",
                    []string{"hasNextPage","hasPreviousPage","startCursor","endCursor"})

                  return &PageInfoExec{ret}
                }

                func (instance *ServiceConnectionExec) Edges() *ServiceEdgeExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "ServiceEdge"},
                    "edges",
                    []string{"cursor"})

                  return &ServiceEdgeExec{ret}
                }

                  func (instance *ServiceConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
                    ret := instance.exec.Client.GetOne(
                      instance.exec,
                      nil,
                      [2]string{"", "AggregateService"},
                      "aggregate",
                      []string{"count"})

                    var v Aggregate
                    _, err := ret.Exec(ctx, &v)
                    return v, err
                  }

          func (instance ServiceConnectionExec) Exec(ctx context.Context) (*ServiceConnection, error) {
            var v ServiceConnection
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance ServiceConnectionExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type ServiceConnectionExecArray struct {
            exec *prisma.Exec
          }

          func (instance ServiceConnectionExecArray) Exec(ctx context.Context) ([]ServiceConnection, error) {
            var v []ServiceConnection
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type ServiceConnection struct {
          
        }

        type PageInfoExec struct {
          exec *prisma.Exec
        }

        

          func (instance PageInfoExec) Exec(ctx context.Context) (*PageInfo, error) {
            var v PageInfo
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance PageInfoExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type PageInfoExecArray struct {
            exec *prisma.Exec
          }

          func (instance PageInfoExecArray) Exec(ctx context.Context) ([]PageInfo, error) {
            var v []PageInfo
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type PageInfo struct {
          HasNextPage bool `json:"hasNextPage"`
HasPreviousPage bool `json:"hasPreviousPage"`
StartCursor *string `json:"startCursor,omitempty"`
EndCursor *string `json:"endCursor,omitempty"`
        }


        type ServiceExec struct {
          exec *prisma.Exec
        }

        
                type DependentServicesParamsExec struct {
                  Where *ServiceWhereInput
OrderBy *ServiceOrderByInput
Skip *int32
After *string
Before *string
First *int32
Last *int32
                }
                func (instance *ServiceExec) DependentServices(params *DependentServicesParamsExec) *ServiceExecArray {
                  var wparams *prisma.WhereParams
                  if params != nil {
                    wparams = &prisma.WhereParams{
                      Where: params.Where,
                      OrderBy: (*string)(params.OrderBy),
                      Skip: params.Skip,
                      After: params.After,
                      Before: params.Before,
                      First: params.First,
                      Last: params.Last,
                    }
                  }

                  ret := instance.exec.Client.GetMany(
                    instance.exec,
                    wparams,
                    [3]string{"ServiceWhereInput", "ServiceOrderByInput", "Service"},
                    "dependentServices",
                    []string{"id","createdAt","updatedAt","name","code","description","status","type","version","canBeRemoved"})

                  return &ServiceExecArray{ret}
                }

          func (instance ServiceExec) Exec(ctx context.Context) (*Service, error) {
            var v Service
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance ServiceExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type ServiceExecArray struct {
            exec *prisma.Exec
          }

          func (instance ServiceExecArray) Exec(ctx context.Context) ([]Service, error) {
            var v []Service
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type Service struct {
          ID string `json:"id"`
CreatedAt string `json:"createdAt"`
UpdatedAt string `json:"updatedAt"`
Name string `json:"name"`
Code string `json:"code"`
Description *string `json:"description,omitempty"`
Status string `json:"status"`
Type string `json:"type"`
Version *string `json:"version,omitempty"`
CanBeRemoved bool `json:"canBeRemoved"`
        }

        type UserEdgeExec struct {
          exec *prisma.Exec
        }

        
                func (instance *UserEdgeExec) Node() *UserExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "User"},
                    "node",
                    []string{"id","name"})

                  return &UserExec{ret}
                }

          func (instance UserEdgeExec) Exec(ctx context.Context) (*UserEdge, error) {
            var v UserEdge
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance UserEdgeExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type UserEdgeExecArray struct {
            exec *prisma.Exec
          }

          func (instance UserEdgeExecArray) Exec(ctx context.Context) ([]UserEdge, error) {
            var v []UserEdge
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type UserEdge struct {
          Cursor string `json:"cursor"`
        }


        type UserExec struct {
          exec *prisma.Exec
        }

        

          func (instance UserExec) Exec(ctx context.Context) (*User, error) {
            var v User
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance UserExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type UserExecArray struct {
            exec *prisma.Exec
          }

          func (instance UserExecArray) Exec(ctx context.Context) ([]User, error) {
            var v []User
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type User struct {
          ID string `json:"id"`
Name string `json:"name"`
        }






        